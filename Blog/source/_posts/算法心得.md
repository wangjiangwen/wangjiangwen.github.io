---
title: 算法心得
date: 2021-01-30 21:30:32
tags:

---

### 1.环形链表

算法核心思路：快慢指针（双指针）

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head) {
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    
    while(slow != NULL && fast->next != NULL && fast->next->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```



### 2.链表反转

算法核心思路：头节点反转

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode* reverseList(struct ListNode* head){

    if (head == NULL) {
        return NULL;
    }
    struct ListNode *currentNode = head;
    struct ListNode *preNode = NULL;
    while(currentNode != NULL){
        struct ListNode *temp = currentNode->next;
        currentNode->next = preNode; 
        preNode = currentNode; 
        currentNode = temp;  
    }
    return preNode;
}
```



### 3.斐波那契数列

算法核心思路：动态规划，c=a+b，非递归

```c
int fib(int n){
  int a = 0;
    int b = (n == 0) ? 0 : 1;   // 0 + 0 = 0  
    int res  =  a + b;         // 0 + 1 = 1
    for(int i = 0; i < n - 1; ++i){
        res  =  (a + b) % 1000000007;
        a = b ;//移动
        b = res;
    }
    return res;
}
```



### 4.连续子数组的最大和

算法核心思路：动态规划，一个max最大值；小于0时从头开始

```c
int maxSubArray(int* nums, int numsSize){
    int max = nums[0];
    int sum = nums[0];
    for (int i = 1; i < numsSize; ++i) {
        if (sum <= 0) {
            sum = nums[i];   
        } else {
            sum = sum + nums[i];
        }
        max = max > sum ? max : sum;
    }
    return max;
}
```



### 5.回文数

算法核心思路：1）反转半数最优

​                          2）反转整个次之（需要有long）

```c
bool isPalindrome(int x){
    if (x < 0 || (x % 10 == 0 && x != 0)) {
        return false;
    }
    int revNumber = 0;
    while(x > revNumber) {
        int number = x%10;
        revNumber = revNumber*10+number;
        x = x/10;
    }
    return(x == revNumber || (x == revNumber / 10));
}
```



### 6.有效的完全平方数

算法核心思路：牛顿迭代；二分法也可以

```c
bool isPerfectSquare(int num){
    if (num < 2) return true;

    long x = num / 2;
    while (x * x > num) {
      x = (x + num / x) / 2;
    }
    return (x * x == num);
}
```



### 7.二叉树的前序遍历

算法核心思路：递归

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 1000);
    *returnSize = 0;
    preorder(root, res, returnSize);
    return res;
}

void preorder(struct TreeNode* root,  int* res,int* returnSize) {
     if (root == NULL) {
        return;
    }
    res[(*returnSize)++]=root->val;
    preorder(root->left,res, returnSize);
    preorder(root->right,res, returnSize);
}
```



### 8.字符串反转

算法核心思路：双指针

```c
void reverseString(char* s, int sSize){
    int middle = sSize/2;
    for(int i = 0; i < middle; i++) {
        int right = sSize - 1 - i;
        swap(s+i, s + right);
    }
}

void swap(char *a, char *b){
   char temp = *a;
   *a=*b;
   *b=temp;
}
```



### 9.二叉树层遍历

算法核心思路：广度优先遍历

```c
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List <List <Integer>> levelOrder = new LinkedList<List<Integer>>();
        if (root == null) {
            return levelOrder;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for(int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            levelOrder.add(0, level);
        }
        return levelOrder;
    }
}
```



### 10.二叉树层深度

算法核心思路：递归

- **常见的 DFS ：** 先序遍历、中序遍历、后序遍历；

- **常见的 BFS ：** 层序遍历（即按层遍历）。

  本次将介绍基于 **后序遍历（DFS）**

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


int maxDepth(struct TreeNode* root){
    if (root == NULL) {
        return 0;
    }
    return getDepth(root, 1);
}

int getDepth(struct TreeNode* node,int depth){
    if (node == NULL || (node->left == NULL && node->right == NULL)) {
        return depth;
    }
    depth += 1;
    int leftDepth = getDepth(node->left, depth);
    int rightDepth = getDepth(node->right, depth);
    return leftDepth > rightDepth ? leftDepth : rightDepth;
}
```



### 11.二叉树层遍历

算法核心思路：广度优先遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List <List <Integer>> levelOrder = new LinkedList<List<Integer>>();
        if (root == null) {
            return levelOrder;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for(int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            levelOrder.add(0, level);
        }
        return levelOrder;
    }
}
```



### 11.二叉树前序遍历非递归

### 算法核心：

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List <Integer> preorder = new ArrayList <Integer>();
        if (root == null) {
            return preorder;
        }
        Stack<TreeNode> stack = new Stack<TreeNode>();
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
            preorder.add(node.val);
        }
        return preorder;
    }
}
```

aaabbabddc -> a3b2a1b1d2c1 

[1,2,3] -> [[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]

